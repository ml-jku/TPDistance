# Distances between Triangles and Points in 3D on a GPU (PyTorch Code)
# Copyright (C) 2021 Andreas Mayr

#----------------------------------------------------------------------------

#The software here is based on software from David Eberly.
#
# David Eberly, Geometric Tools, Redmond WA 98052
# Copyright (c) 1998-2019
# Distributed under the Boost Software License, Version 1.0.
# http://www.boost.org/LICENSE_1_0.txt
# http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
# File Version: 3.0.0 (2016/06/19)
#
#
#ATTENTION:
#
#FOR THIS SOFTWARE, WE DID NOT TAKE ANY CARE FOR ANY POTENTIAL 
#NUMERICAL PROBLEMS (DATA TYPE CONVERSIONS, CUT-OFF ERRORS, 
#NUMERICAL PRECISION, ETC.). THIS SOFTWARE DOES VERY LIKELY 
#NOT EXACTLY REPRODUCE THE RESULTS FROM THE SOFTWARE OF 
#DAVID EBERLY. THIS SOFTWARE MAY BE BASED ON DIFFERENT DATA TYPES
#WITH DIFFERENT NUMERICAL PRECISIONS AND FOR FURTHER USAGE OF THIS
#SOFTWARE, ONE SHOULD PAY ATTENTION TO THIS.
#
#----------------------------------------------------------------------------
#
#Boost Software License - Version 1.0 - August 17th, 2003
#
#Permission is hereby granted, free of charge, to any person or organization
#obtaining a copy of the software and accompanying documentation covered by
#this license (the "Software") to use, reproduce, display, distribute,
#execute, and transmit the Software, and to prepare derivative works of the
#Software, and to permit third-parties to whom the Software is furnished to
#do so, all subject to the following:
#
#The copyright notices in the Software and this entire statement, including
#the above license grant, this restriction and the following disclaimer,
#must be included in all copies of the Software, in whole or in part, and
#all derivative works of the Software, unless such copies or derivative
#works are solely in the form of machine-executable object code generated by
#a source language processor.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
#SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
#FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
#ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#DEALINGS IN THE SOFTWARE.

#----------------------------------------------------------------------------

#As far as it is compatible with the Boost Software License - Version 1.0
#from above, the additional parts of this software, that extend the work of
#David Eberly are free software: you can redistribute them and/or modify
#them under the terms of the GNU General Public License as published by
#the Free Software Foundation, version 3 (GPLv3) of the License .
#Otherwise (in case of incompatible License terms) the respective
#License terms from the Boost Software License - Version 1.0 
#have priority over the incompatible terms from GPLv3.
#
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <https://www.gnu.org/licenses/>.

#----------------------------------------------------------------------------

#IN ANY CASE, THE FOLLOWING HOLDS FOR THIS SOFTWARE:

#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
#SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
#FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
#ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#DEALINGS IN THE SOFTWARE.

#----------------------------------------------------------------------------



#expected Parameters:
#points with shape (nrPoints, 3 [coordinates])
#triangles with shape (nrTriangles, 3 [corner points], 3 [coordinates])

diff=torch.reshape(points,(-1,1,3))-torch.reshape(tcoord[:,0,:],(1,-1,3))
edge0=tcoord[:,1,:]-tcoord[:,0,:]
edge1=tcoord[:,2,:]-tcoord[:,0,:]
a00=torch.reshape(torch.sum(edge0*edge0, 1),(1,-1))
a01=torch.reshape(torch.sum(edge0*edge1, 1), (1,-1))
a11=torch.reshape(torch.sum(edge1*edge1, 1), (1,-1))
b0=-torch.sum(diff*torch.reshape(edge0, (1,-1,3)), 2)
b1=-torch.sum(diff*torch.reshape(edge1, (1,-1,3)), 2)
det=a00*a11-a01*a01
t0=a01*b1-a11*b0
t1=a01*b0-a00*b1

cond_1111=a11+b1-a01-b0>=a00-2.0*a01+a11
t0_1111=torch.where(cond_1111, torch.as_tensor(1.0, device=device).float(), (a11+b1-a01-b0)/(a00-2.0*a01+a11))
t1_1111=torch.where(cond_1111, torch.as_tensor(0.0, device=device).float(), 1.0-((a11+b1-a01-b0)/(a00-2.0*a01+a11)))

t0_1110=torch.as_tensor(0.0, device=device).float()
t1_1110=torch.as_tensor(1.0, device=device).float()

cond_111=a11+b1-a01-b0<=0.0
t0_111=torch.where(cond_111, t0_1110, t0_1111)
t1_111=torch.where(cond_111, t1_1110, t1_1111)

cond_11011=b0>=0.0
t0_11011=torch.where(cond_11011, torch.as_tensor(0.0, device=device).float(), -b0/a00)
t1_11011=torch.as_tensor(0.0, device=device).float()

t0_11010=torch.as_tensor(1.0, device=device).float()
t1_11010=torch.as_tensor(0.0, device=device).float()

cond_1101=a00+b0<=0.0
t0_1101=torch.where(cond_1101, t0_11010, t0_11011)
t1_1101=torch.where(cond_1101, t1_11010, t1_11011)

cond_1100=((a00+b0)-(a01+b1))>=(a00-(2.0)*a01+a11)
t0_1100=torch.where(cond_1100, torch.as_tensor(0.0, device=device).float(), 1.0-(((a00+b0)-(a01+b1))/(a00-(2.0)*a01+a11)))
t1_1100=torch.where(cond_1100, torch.as_tensor(1.0, device=device).float(), ((a00+b0)-(a01+b1))/(a00-(2.0)*a01+a11))

cond_110=a00+b0>a01+b1
t0_110=torch.where(cond_110, t0_1100, t0_1101)
t1_110=torch.where(cond_110, t1_1100, t1_1101)

cond_11=t1<0.0
t0_11=torch.where(cond_11, t0_110, t0_111)
t1_11=torch.where(cond_11, t1_110, t1_111)

cond_1011=b1>=0.0
t0_1011=torch.as_tensor(0.0, device=device).float()
t1_1011=torch.where(cond_1011, torch.as_tensor(0.0, device=device).float(), -b1/a11)

t0_1010=torch.as_tensor(0.0, device=device).float()
t1_1010=torch.as_tensor(1.0, device=device).float()

cond_101=(a11+b1)<=0.0
t0_101=torch.where(cond_101, t0_1010, t0_1011)
t1_101=torch.where(cond_101, t1_1010, t1_1011)

cond_100=((a11+b1)-(a01+b0)) >= (a00-(2.0)*a01+a11)
t0_100=torch.where(cond_100, torch.as_tensor(1.0, device=device).float(), ((a11+b1)-(a01+b0))/(a00-(2.0)*a01+a11))
t1_100=torch.where(cond_100, torch.as_tensor(0.0, device=device).float(), 1.0-(((a11+b1)-(a01+b0))/(a00-(2.0)*a01+a11)))

cond_10=(a11+b1)>(a01+b0)
t0_10=torch.where(cond_10, t0_100, t0_101)
t1_10=torch.where(cond_10, t1_100, t1_101)

cond_1=t0<0.0
t0_1=torch.where(cond_1, t0_10, t0_11)
t1_1=torch.where(cond_1, t1_10, t1_11)

t0_011=(a01*b1-a11*b0)*(1.0/det)
t1_011=(a01*b0-a00*b1)*(1.0/det)

cond_0101=-b0>=a00
t0_0101=torch.where(cond_0101, torch.as_tensor(1.0, device=device).float(), -b0/a00)
t1_0101=torch.as_tensor(0.0, device=device).float()

t0_0100=torch.as_tensor(0.0, device=device).float()
t1_0100=torch.as_tensor(0.0, device=device).float()

cond_010=b0 >= 0.0
t0_010=torch.where(cond_010, t0_0100, t0_0101)
t1_010=torch.where(cond_010, t1_0100, t1_0101)

cond_01=t1<0.0
t0_01=torch.where(cond_01, t0_010, t0_011)
t1_01=torch.where(cond_01, t1_010, t1_011)

cond_0011=-b1>=a11
t0_0011=torch.as_tensor(0.0, device=device).float()
t1_0011=torch.where(cond_0011, torch.as_tensor(1.0, device=device).float(), -b1/a11)

t0_0010=torch.as_tensor(0.0, device=device).float()
t1_0010=torch.as_tensor(0.0, device=device).float()

cond_001=b1>=0.0
t0_001=torch.where(cond_001, t0_0010, t0_0011)
t1_001=torch.where(cond_001, t1_0010, t1_0011)

cond_00011=-b1>=a11
t0_00011=torch.as_tensor(0.0, device=device).float()
t1_00011=torch.where(cond_00011, torch.as_tensor(1.0, device=device).float(), -b1/a11)

t0_00010=torch.as_tensor(0.0, device=device).float()
t1_00010=torch.as_tensor(0.0, device=device).float()

cond_0001=b1>=0.0
t0_0001=torch.where(cond_0001, t0_00010, t0_00011)
t1_0001=torch.where(cond_0001, t1_00010, t1_00011)

cond_0000=-b0>=a00
t0_0000=torch.where(cond_0000, torch.as_tensor(1.0, device=device).float(), -b0/a00)
t1_0000=torch.as_tensor(0.0, device=device).float()

cond_000=b0<0.0
t0_000=torch.where(cond_000, t0_0000, t0_0001)
t1_000=torch.where(cond_000, t1_0000, t1_0001)

cond_00=t1<0.0
t0_00=torch.where(cond_00, t0_000, t0_001)
t1_00=torch.where(cond_00, t1_000, t1_001)

cond_0=t0<0.0
t0_0=torch.where(cond_0, t0_00, t0_01)
t1_0=torch.where(cond_0, t1_00, t1_01)

cond=t0+t1<=det
t0=torch.where(cond, t0_0, t0_1)
t1=torch.where(cond, t1_0, t1_1)

vecShape=(-1,)+tuple(edge0.shape)
factorShape=tuple(t0.shape)+(-1,)
startPoint=torch.reshape(tcoord[:,0,:], vecShape)
t0=torch.reshape(t0, factorShape)
t1=torch.reshape(t1, factorShape)
edge0=torch.reshape(edge0, vecShape)
edge1=torch.reshape(edge1, vecShape)
minPoint=startPoint+t0*edge0+t1*edge1

diffVec=torch.reshape(points, (-1,1,3))-minPoint
dists=torch.sqrt(torch.sum(diffVec**2, 2))

